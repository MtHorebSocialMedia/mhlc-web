<template>
  <router-view />
  <v-overlay
    :model-value="showLoading"
    class="align-center justify-center"
  >
    <v-progress-circular
      color="primary"
      size="64"
      indeterminate
    />
  </v-overlay>
</template>

<script setup>

    import { getStores } from '@/store';
    import { ref } from 'vue';
    import { useContentStore } from '@/store/content';
    import { useConfigurationStore } from '@/store/configuration';
    import router from '@/router';
    import { onShowLoading, onHideLoading } from '@/utils/eventBus';

    // Register callbacks for event bus
    onShowLoading(() => {
      showLoading.value = true;
    });
    onHideLoading(() => {
      showLoading.value = false;
    });

    // Show/hide loading animation on router navigation
    router.beforeEach(() => {
      showLoading.value = true;
    });
    router.afterEach(() => {
      showLoading.value = false;
    });

    // Show/hide loading animation with every store action
    const showLoading = ref(false);
    getStores().forEach((store) => {
      store.$onAction(({ after, onError }) => {
        showLoading.value = true;
        after(() => {
          showLoading.value = false;
        });
        onError(() => {
          showLoading.value = false;
        });
      });
    });

    // initialize content
    useContentStore().fetchContent();

    (async function() {
      // initialize site configuration and enable traffic tracking if configured
      const configuration = await useConfigurationStore().getConfiguration();

      if (configuration.enableTrafficTracking) {

        // helper to load an external script and return a Promise
        // Note: this function was generated by copilot
        function loadScript(src, { async = true, attrs = {} } = {}) {
          return new Promise((resolve, reject) => {
            if (document.querySelector(`script[src="${src}"]`)) return resolve(); // already loaded
            const s = document.createElement('script');
            s.src = src;
            s.async = async;
            Object.entries(attrs).forEach(([k, v]) => s.setAttribute(k, v));
            s.onload = () => resolve(s);
            s.onerror = (e) => reject(e);
            document.head.appendChild(s);
          });
        }

        // Enable IdentityPXL tracking
        await loadScript('https://cdn.v3.identitypxl.app/pixels/866214cd-5e17-4429-b2df-e32855b272ff/p.js')

        // Enable Microsoft Clarity
        window.clarity = window.clarity || function() { (window.clarity.q = window.clarity.q || []).push(arguments) };
        await loadScript('https://www.clarity.ms/tag/v84w1tow2i');

        // Enable Google Analytics
        await loadScript('https://www.googletagmanager.com/gtag/js?id=G-E2W4Y1G50N');

        window.dataLayer = window.dataLayer || [];
        window.gtag = (...args) => {
          window.dataLayer.push(args);
        }
        window.gtag('js', new Date());
        window.gtag('config', 'G-E2W4Y1G50N');
      }
    })()

</script>
